<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
    <title>Test coverage report: musicquiz.quiz.models</title>
    <style type="text/css" media="screen">
      a
      {
        color: #3d707a;
      }
      
      a:hover, a:active
      {
        color: #bf7d18;
      }
    
      body 
      {
        font-family: "Lucida Sans Unicode", "Lucida Grande", sans-serif;
        font-size: 13px;
      }
      
      .nav 
      {
        font-size: 12px;
        margin-left: 50px;
      }

      .ignored
      {
        color: #707070;
      }

      .executed 
      {
        color: #3d9900;
      }

      .missed 
      {
        color: red;
        font-weight: bold;
      }

      .excluded 
      {
        color: #6090f0;
        font-weight: lighter;
      }
    
      #content-header 
      {
        font-size: 12px;
        padding: 18px 0 18px 50px;
      }

      #content-header h1 
      {
        font-size: 16px;
        margin: 10px 0 0 0;
        color: #909090;
      }
      
      #module-name
      {
        color: #583707;
      }
    
      #content-header p
      {
        font-size: 13px;
        margin: 0;
        color: #909090;
      }

      #content-header .normal 
      {
        color: #609030;
      }

      #content-header .warning 
      {
        color: #d0a000;
      }

      #content-header .critical 
      {
        color: red;
      }
      
      #source-listing 
      {
        margin-bottom: 24px;
      }

      #source-listing ol 
      {
        padding: 0 0 0 50px;
        width: 90%;
        font-family: monospace;
        list-style-position: outside;
      }

      #source-listing ol li 
      {
        line-height: 18px;
        font-size: small;
      }
        
      #source-listing ol code 
      {
        padding:  0 .001em 0 0; /* Firefox doesn't render empty li's properly */
        font-size: medium;
        white-space: pre;
      }
   </style>
  </head>

  <body>

<div class="nav">
  <a href="musicquiz.quiz.forms.html">musicquiz.quiz.forms</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="musicquiz.quiz.utility.html">musicquiz.quiz.utility</a>
</div>

<div id="content-header">
  <h1>
    <span id="module-name">musicquiz.quiz.models</span>:
    158 total statements,
    <span class="normal">97.2% covered</span>
  </h1>
  <p>Generated: Mon 2010-05-10 17:51 FLE Daylight Time</p>
  <p>Source file: c:\documents and settings\marius\desktop\musicquiz\src\musicquiz\quiz\models.py</p>
  <p>
    Stats:
    <span class="executed">137 executed</span>,
    <span class="missed">4 missed</span>,
    <span class="excluded">17 excluded</span>,
    <span class="ignored">137 ignored</span> 
  </p> 
</div>

<div id="source-listing">
  <ol>
    <li class="excluded"><code>from django.db import models</code></li>
<li class="excluded"><code>from django.db import IntegrityError</code></li>
<li class="excluded"><code>from django.conf import settings</code></li>
<li class="excluded"><code>from utility import extract_youtube_code</code></li>
<li class="excluded"><code>import gdata.youtube</code></li>
<li class="excluded"><code>import gdata.youtube.service</code></li>
<li class="excluded"><code>import pylast</code></li>
<li class="excluded"><code>import random</code></li>
<li class="excluded"><code>import urllib</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>EPSILON = 1e-9</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class Error(Exception):</code></li>
<li class="ignored"><code>    """Base class for exceptions in this module."""</code></li>
<li class="executed"><code>    pass</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class QuizModelError(Error):</code></li>
<li class="ignored"><code>    """Exception class.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>    New exception classes may be declared in the future for some special</code></li>
<li class="ignored"><code>    situations in this module, but for now all errors use this class.</code></li>
<li class="ignored"><code>    """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def __init__(self, value):</code></li>
<li class="executed"><code>        self.value = value</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def __str__(self):</code></li>
<li class="executed"><code>        return repr(self.value)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code># Create your models here.</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class Artist(models.Model):</code></li>
<li class="ignored"><code>    """Artist model class."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    name = models.CharField(max_length=128)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def fetch_similar(self):</code></li>
<li class="ignored"><code>        """Fetch similar artists from last.fm database."""</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        pass</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def fetch_tracks(self):</code></li>
<li class="ignored"><code>        """Fetch the titles of artist's tracks from last.fm."""</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        pass</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        return u'%s' % (self.name)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class Track(models.Model):</code></li>
<li class="ignored"><code>    """Track model class."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    artist = models.ForeignKey(Artist)</code></li>
<li class="executed"><code>    title = models.CharField(max_length=256)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    youtube_code = models.CharField(max_length=20, null=True, blank=True)</code></li>
<li class="executed"><code>    youtube_duration = models.IntegerField(null=True, blank=True)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @staticmethod</code></li>
<li class="executed"><code>    def pick_random(exclude=[]):</code></li>
<li class="ignored"><code>        """Pick a random track which is not in the exclude list.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Returned track is guaranteed to have youtube code and duration.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        exclude_pks = [track.pk for track in exclude]</code></li>
<li class="executed"><code>        try:</code></li>
<li class="executed"><code>            track = random.choice(Track.objects.exclude(pk__in=exclude_pks))</code></li>
<li class="executed"><code>        except IndexError, e:</code></li>
<li class="executed"><code>            raise ValueError('could not pick any track')</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="executed"><code>            if not track.has_youtube_info():</code></li>
<li class="executed"><code>                track.update_youtube_info()</code></li>
<li class="executed"><code>            if track.has_youtube_info():</code></li>
<li class="executed"><code>                return track</code></li>
<li class="ignored"><code>            else:</code></li>
<li class="missed"><code>                return Track.pick_random(exclude=exclude + [track])</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def has_youtube_info(self):</code></li>
<li class="ignored"><code>        """Check if track has all required info about its youtube video."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        youtube_info = [self.youtube_code, self.youtube_duration]</code></li>
<li class="executed"><code>        return all(field is not None for field in youtube_info)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def update_youtube_info(self):</code></li>
<li class="ignored"><code>        """Find youtube video for the track and update youtube info fields."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        service = gdata.youtube.service.YouTubeService()</code></li>
<li class="executed"><code>        query = gdata.youtube.service.YouTubeVideoQuery()</code></li>
<li class="executed"><code>        query_string = u'%s %s' % (self.artist, self.title)</code></li>
<li class="executed"><code>        query.vq = query_string.encode('utf-8')</code></li>
<li class="executed"><code>        feed = service.YouTubeQuery(query)</code></li>
<li class="executed"><code>        if len(feed.entry) &gt; 0:</code></li>
<li class="executed"><code>            entry = feed.entry[0]</code></li>
<li class="executed"><code>            url = entry.GetSwfUrl()</code></li>
<li class="executed"><code>            if url:</code></li>
<li class="executed"><code>                self.youtube_code = extract_youtube_code(url)</code></li>
<li class="executed"><code>                self.youtube_duration = entry.media.duration.seconds</code></li>
<li class="executed"><code>                self.save()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def fetch_similar(self, limit=None):</code></li>
<li class="ignored"><code>        """Fetch a list or similar tracks and save them in the database.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Returns the count of newly added tracks.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if limit is not None and limit &lt; 0:</code></li>
<li class="executed"><code>            raise ValueError('limit must be a positive integer')</code></li>
<li class="executed"><code>        network = pylast.get_lastfm_network(api_key=settings.LASTFM_API_KEY)</code></li>
<li class="executed"><code>        lastfm_track = network.get_track(unicode(self.artist), self.title)</code></li>
<li class="executed"><code>        similar = lastfm_track.get_similar()</code></li>
<li class="executed"><code>        new_songs = 0</code></li>
<li class="executed"><code>        if limit is not None:</code></li>
<li class="executed"><code>            similar = similar[:limit]</code></li>
<li class="executed"><code>        for similar_track in similar:</code></li>
<li class="executed"><code>            artist_name = similar_track.item.artist.name</code></li>
<li class="executed"><code>            title = similar_track.item.title</code></li>
<li class="executed"><code>            artist, _ = Artist.objects.get_or_create(name=artist_name)</code></li>
<li class="executed"><code>            result = Track.objects.get_or_create(artist=artist, title=title)</code></li>
<li class="executed"><code>            if result[1]:</code></li>
<li class="executed"><code>                new_songs += 1</code></li>
<li class="executed"><code>        return new_songs</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        return u'%s \u2013 %s' % (self.artist, self.title)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class Question(models.Model):</code></li>
<li class="ignored"><code>    """Quiz question model class."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    QUESTION_STATES = (</code></li>
<li class="ignored"><code>        ('NOANSWER', 'Not answered'),</code></li>
<li class="ignored"><code>        ('ANSWERED', 'Submitted'),</code></li>
<li class="ignored"><code>        ('TIMEOUT', 'Timeout'),</code></li>
<li class="ignored"><code>        ('SKIPPED', 'Skipped'),</code></li>
<li class="ignored"><code>        ('REPORTED', 'Reported as bad'),</code></li>
<li class="ignored"><code>    )</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    game = models.ForeignKey('Game', related_name='questions')</code></li>
<li class="executed"><code>    number = models.IntegerField()</code></li>
<li class="executed"><code>    state = models.CharField(max_length=8,</code></li>
<li class="ignored"><code>                choices=QUESTION_STATES, default='NOANSWER')</code></li>
<li class="executed"><code>    correct_answer = models.ForeignKey(Track, related_name='in_question')</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    points = models.FloatField(null=True, blank=True)</code></li>
<li class="executed"><code>    given_answer = models.ForeignKey(Track, null=True, blank=True)</code></li>
<li class="executed"><code>    remaining_time = models.FloatField(null=True, blank=True)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def is_answered(self):</code></li>
<li class="ignored"><code>        """Check if the user has reacted in some way to the question."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        return self.state != 'NOANSWER'</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def answered_correctly(self):</code></li>
<li class="ignored"><code>        """Check if the question was answered correctly."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        return self.correct_answer == self.given_answer</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def make_guess(self, guess):</code></li>
<li class="ignored"><code>        """Try to guess the answer.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Dictionary `guess` must contain 'answer' and 'remaining_time' keys.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        self.remaining_time = guess['remaining_time']</code></li>
<li class="executed"><code>        if 'answer' in guess.keys():</code></li>
<li class="executed"><code>            given_answer = Track.objects.get(id=guess['answer'])</code></li>
<li class="executed"><code>            self.given_answer = given_answer</code></li>
<li class="executed"><code>        if abs(self.remaining_time) &gt; EPSILON:</code></li>
<li class="executed"><code>            self.state = 'ANSWERED'</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="executed"><code>            self.state = 'TIMEOUT'</code></li>
<li class="executed"><code>        self.calculate_points()</code></li>
<li class="executed"><code>        self.save()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def calculate_points(self):</code></li>
<li class="ignored"><code>        """Recalculate the question point field and return its value."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if self.answered_correctly():</code></li>
<li class="executed"><code>            self.points = self.remaining_time</code></li>
<li class="executed"><code>        elif self.state == 'ANSWERED' and not self.answered_correctly():</code></li>
<li class="executed"><code>            self.points = -10</code></li>
<li class="ignored"><code>        else:</code></li>
<li class="executed"><code>            self.points = 0</code></li>
<li class="executed"><code>        self.save()</code></li>
<li class="executed"><code>        return self.points</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def skip_question(self):</code></li>
<li class="ignored"><code>        """Skip question."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        self.given_answer = None</code></li>
<li class="executed"><code>        self.remaining_time = None</code></li>
<li class="executed"><code>        self.state = 'SKIPPED'</code></li>
<li class="executed"><code>        self.calculate_points()</code></li>
<li class="executed"><code>        self.save()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def is_timeout(self):</code></li>
<li class="ignored"><code>        """Check if the question was answered in time."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        return self.state == 'TIMEOUT'</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def get_choices(self, count=8):</code></li>
<li class="ignored"><code>        """Return a list of randomly selected possible answers.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        Correct answer is always one of the possible choices, but</code></li>
<li class="ignored"><code>        other tracks in the list are very likely to be different</code></li>
<li class="ignored"><code>        each time this method gets called.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if count &lt; 1:</code></li>
<li class="executed"><code>            raise ValueError('there must be at least one answer')</code></li>
<li class="executed"><code>        query = Track.objects.exclude(pk__in=[self.correct_answer.pk])</code></li>
<li class="executed"><code>        choices = random.sample(query, count - 1) + [self.correct_answer]</code></li>
<li class="executed"><code>        random.shuffle(choices)</code></li>
<li class="executed"><code>        return choices</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        return u'%s %s. %s' % (self.game, self.number, self.correct_answer)</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>class Game(models.Model):</code></li>
<li class="ignored"><code>    """Quiz game model class."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    quiz_length = models.IntegerField()</code></li>
<li class="executed"><code>    date_started = models.DateTimeField(auto_now_add=True)</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def next_question(self):</code></li>
<li class="ignored"><code>        """Create and return next question for the game."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if self.is_game_finished():</code></li>
<li class="executed"><code>            raise QuizModelError('game is already over')</code></li>
<li class="executed"><code>        seen_tracks = [q.correct_answer for q in self.questions.all()]</code></li>
<li class="executed"><code>        answer = Track.pick_random(exclude=seen_tracks)</code></li>
<li class="executed"><code>        number = self.questions.count() + 1</code></li>
<li class="executed"><code>        question = Question.objects.create(game=self,</code></li>
<li class="ignored"><code>                        correct_answer=answer, number=number)</code></li>
<li class="executed"><code>        return question</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    @staticmethod</code></li>
<li class="ignored"><code>    def highscore_queryset():</code></li>
<li class="ignored"><code>        """Return the QuerySet for the list of top scorers.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        If two players have equal scores, the newer one is rated better.</code></li>
<li class="ignored"><code>        This is needed to eliminate the possibility that a player makes</code></li>
<li class="ignored"><code>        a perfect score and then stays in the first position forever.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="missed"><code>        return Game.objects.annotate(score=models.Sum('questions__points')) \</code></li>
<li class="ignored"><code>                .order_by('-score', '-date_started')</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def total_score(self):</code></li>
<li class="ignored"><code>        """Return total score."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        return sum(q.calculate_points() for q in self.questions.all())</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def correct_answers(self):</code></li>
<li class="ignored"><code>        """Return the number of correctly in time answered questions."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        return sum(1 for q in self.questions.all()</code></li>
<li class="ignored"><code>                        if q.answered_correctly() and not q.is_timeout())</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def has_started(self):</code></li>
<li class="ignored"><code>        """Check if the game has started.</code></li>
<li class="ignored"><code></code></li>
<li class="ignored"><code>        The game starts when user requests the first question.</code></li>
<li class="ignored"><code>        """</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        return self.questions.count() != 0</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def current_question(self):</code></li>
<li class="ignored"><code>        """Return current question."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if not self.has_started():</code></li>
<li class="executed"><code>            raise QuizModelError('game has not started')</code></li>
<li class="executed"><code>        return self.questions.order_by('-number')[0]</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def remaining_questions(self):</code></li>
<li class="ignored"><code>        """Return the number of remaining questions."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        return self.quiz_length - self.questions.all().count()</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>    def is_game_finished(self):</code></li>
<li class="ignored"><code>        """Check if the game has already finished."""</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        if not self.questions.count():</code></li>
<li class="executed"><code>            return False</code></li>
<li class="ignored"><code></code></li>
<li class="executed"><code>        last_question_answered = self.current_question().is_answered()</code></li>
<li class="executed"><code>        all_questions_shown = self.questions.count() == self.quiz_length</code></li>
<li class="executed"><code>        return all_questions_shown and last_question_answered</code></li>
<li class="ignored"><code></code></li>
<li class="excluded"><code>    def __unicode__(self):</code></li>
<li class="excluded"><code>        return u'#%d' % (self.id)</code></li>
  </ol>
</div>

<div class="nav">
  <a href="musicquiz.quiz.forms.html">musicquiz.quiz.forms</a> &lt;&lt;
  <a href="../index.html">index</a>
  &gt;&gt; <a href="musicquiz.quiz.utility.html">musicquiz.quiz.utility</a>
</div>

  </body>
</html>

